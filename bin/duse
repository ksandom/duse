#!/bin/bash
# duse - A directory shim manager for managing an source and a read-only cache of data.

# Make sure we have $HOME set so that we can make assumptions based on it, and the unit tests can override it.
if [ "$HOME" == '' ]; then
  HOME=~
fi
duseHome="$HOME/.config/duse"
contextHome="$duseHome/contexts"
warnExitCode=0

if [ -e "$duseHome/overrides" ]; then
  . "$duseHome/overrides"
fi


# ./bin/duse --addContext shoots "A collection of photo/video shoots."
function addContext # 00: Add a new context that will have sources and cache associated with it. Usage: addContext shortName "Description."
{
  contextName="$1"
  contextDescription="$2"
  contextPath="$contextHome/$contextName"
  
  if [ "$1" == '' ]; then
    echo "Need a name and description." >&2
    return 1
  fi
  
  if [ -e "$contextPath" ]; then
    echo "Context $contextName already exists." >&2
    return 1
  fi
  
  mkdir -pv "$contextPath"
  echo "$contextDescription" | tee "$contextPath/description"
}

function private_listContextThing
{
  contextName="$1"
  thingName="$2"
  thingDirName="$3"
  thingPath="$contextHome/$context/$thingDirName"
  
  if [ -e "$thingPath" ]; then
    echo "  $thingName:"
    if [ "$(ls -1 "$thingPath" | wc -l)" -lt 1 ]; then
      echo "    None anymore."
      rmdir "$thingPath"
    else
      for thingItem in "$thingPath"/*; do
        echo "    $(basename "$thingItem"): $(cat $thingItem)"
      done
    fi
  else
    echo "  $thingName: None yet."
  fi
}

function private_showContext
{
  context="$1"
  echo "$context: $(cat "$contextHome/$context/description")"
  
  private_listContextThing "$context" "Sources" "sources"
  private_listContextThing "$context" "Cache" "cache"
  private_listContextThing "$context" "Workspaces" "workspaces"
}

function listContexts # List contexts and their associated data.
{
  if [ -e "$contextHome" ]; then
    while read context; do
      private_showContext "$context"
    done < <(ls "$contextHome")
  else
    echo "No contexts yet." >&2
    exit 1
  fi
}

function private_contextExists
{
  local contextName="$1"
  local contextPath="$contextHome/$contextName"
  
  if [ ! -e "$contextPath" ]; then
    return 1
  else
    return 0
  fi
}

function deleteContext # Delete a context. --deleteContext contextName . Note that this will delete all duse references to the context, but will not check any cases where it might be used. If they exist, they will be orphaned and unmanaged. The context can be manually re-created, and the references will be usable again.
{
  contextName="$1"
  contextPath="$contextHome/$contextName"
  
  if ! private_contextExists "$contextName"; then
    echo "Context \"$contextName\" not found." >&2
    return 1
  fi
  
  rm -Rfv "$contextPath"
}



function private_sourceName # Gives us a unique name based on a file path.
{
  local sourcePath="$1"
  
  echo "$sourcePath" | sed "s#\(/\| \)#_#g"
}

function private_sourceExists
{
  local contextName="$1"
  local sourceVanillaPath="$2"
  local sourcePath="$(private_sourcePath "$contextName" "$sourceVanillaPath")"
  
  if ! private_contextExists "$contextName"; then
    echo "Context \"$contextName\" not found." >&2
    return 1
  fi
  
  if [ ! -e "$sourcePath" ]; then
    return 1
  else
    return 0
  fi
}

function private_getSources
{
  local contextName="$1"
  local sourcesPath="$contextHome/$contextName/sources"
  
  if [ ! -e "$sourcesPath" ]; then
    echo "It looks like the current context doesn't have any sources defined yet." >&2
    return 1
  fi
  
  ls -1 "$sourcesPath"
}

function private_sourcePath
{
  local contextName="$1"
  local sourceVanillaPath="$2"
  local sourcesPath="$contextHome/$contextName/sources"
  local sourceVanillaName="$3"
  
  if [ "$sourceVanillaName" == '' ]; then
    local sourceName="$(private_sourceName "$sourceVanillaPath")"
  else
    local sourceName="$(private_sourceName "$sourceVanillaName")"
  fi
  
  echo "$sourcesPath/$sourceName"
}

function addSource # 01: Add a source to a context. --addsource contextName sourcePath [sourceName]
{
  contextName="$1"
  contextPath="$contextHome/$contextName"
  sourcesPath="$contextHome/$contextName/sources"
  sourceVanillaPath="$2"
  fullSourcePath="$(realpath "$2")"
  sourceName="$3"
  sourcePath="$(private_sourcePath "$contextName" "$sourceVanillaPath" "$sourceName")"
  
  if ! private_contextExists "$contextName"; then
    echo "Context \"$contextName\" not found." >&2
    return 1
  fi
  
  # TODO Test for the sourcePath existing on disk.
  
  if private_sourceExists "$contextName" "$sourceVanillaPath";  then
    echo "Source \"$sourceVanillaPath\" already exists within context \"$contextName\"." >&2
    return 1
  fi
  
  mkdir -p "$sourcesPath"
  echo "$fullSourcePath" > "$sourcePath"
}

function deleteSource # Delete a source from a context. --deleteSource contextName sourcePath
{
  contextName="$1"
  contextPath="$contextHome/$contextName"
  sourcesPath="$contextHome/$contextName/sources"
  sourceVanillaPath="$2"
  fullSourcePath="$(realpath "$2")"
  sourcePath="$(private_sourcePath "$contextName" "$sourceVanillaPath")"
  
  if ! private_contextExists "$contextName"; then
    echo "Context \"$contextName\" not found." >&2
    return 1
  fi
  
  if ! private_sourceExists "$contextName" "$sourceVanillaPath";  then
    echo "Source \"$sourceVanillaPath\" does not exist within context \"$contextName\"." >&2
    return 1
  fi
  
  rm "$sourcePath"
}

function setCache # 02: Set the location where you want cache to be stored. --setCache contextName /path/to/cache/location
{
  contextName="$1"
  contextPath="$contextHome/$contextName"
  cachePath="$(realpath "$2")"
  
  if ! private_contextExists "$contextName"; then
    echo "Context \"$contextName\" not found." >&2
    return 1
  fi
  
  if [ ! -e "$cachePath" ]; then
    echo "The path \"$cachePath\" doesn't appear to exist." >&2
    return 1
  fi
  
  mkdir -p "$contextPath/cache"
            echo "$cachePath" > "$contextPath/cache/location"
}

function private_registerWorkspace
{
  local contextName="$1"
  local contextPath="$contextHome/$contextName"
  local workspaceName="$2"
  local workspacePath="`pwd`/$workspaceName"
  local workspaceNiceName=$(private_sourceName "$workspacePath")
  local action="${3:-register}"
  
  case "$action" in
    "register")
      mkdir -p "$contextPath/workspaces"
      echo "$workspacePath" > "$contextPath/workspaces/$workspaceNiceName"
    ;;
    "unregister")
      rm "$contextPath/workspaces/$workspaceNiceName"
      if [ "$(ls "$contextPath/workspaces" | wc -l)" -lt 1 ]; then
        rmdir "$contextPath/workspaces"
      fi
    ;;
  esac
}

function createWorkspace # 03: Create a workspace that will use the context that you have created. --createWorkspace contextName workspaceName
{
  contextName="$1"
  contextPath="$contextHome/$contextName"
  workspaceName="$2"
  
  mkdir -p "$workspaceName/.duse"
  echo "$contextName" > "$workspaceName/.duse/context"
  
  private_registerWorkspace "$contextName" "$workspaceName"
}

function deleteWorkspace # Delete a workspace. --createWorkspace workspaceNameOrPath
{
  workspaceNameOrPath="$1"
  if [ ! -e "$workspaceNameOrPath/.duse" ]; then
    echo "Could not find a valid workspace at \"$workspaceNameOrPath\"." >&2
    return 1
  fi
  
  contextName="$(cat "$workspaceNameOrPath/.duse/context")"
  contextPath="$contextHome/$contextName"
  
  # TODO uncache everything in this workspace.
  
  private_registerWorkspace "$contextName" "$workspaceNameOrPath" 'unregister'
  rm -Rvf "$workspaceNameOrPath"
}

function info # Show basic information about the current workspace.
{
  if [ ! -e '.duse/context' ]; then
    echo "This does not appear to be a workspace." >&2
    return 1
  fi
  
  private_showContext "$(cat '.duse/context')"
}

function private_whichSource
{
  local contextName="$1"
  local contextPath="$contextHome/$contextName"
  local linkSource="$2"
  
  for source in "$contextPath/sources"/*; do
    resolvedSource="$(cat "$source")"
    if [ "$resolvedSource" == "$linkSource" ]; then
      echo "$(basename "$source")"
      return 0
    fi
  done
  return 1
}

function private_getEntryType
{
  local contextName="$1"
  local contextPath="$contextHome/$contextName"
  local entry="$2"

  linkSource="$(dirname "$(readlink "$entry")")"
  
  
  if [ -L "$entry" ]; then
    if [ "$linkSource" == "$(cat "$contextPath/cache/location")/$contextName" ]; then
      echo "Cached"
    elif sounds="$(private_whichSource "$contextName" "$linkSource")"; then
      echo "Uncached"
    else
      echo "Invalid link"
      return 1
    fi
  elif [ -f "$entry" ]; then # Directly placed files are not managed by duse.
    echo "Invalid file"
    return 1
  elif [ -d "$entry" ]; then # Directly placed directories are not managed by duse.
    echo "Invalid directory"
    return 1
  fi
}

function private_entryInCache
{
  local context="$1"
  local entry="$2"
  
  if [ -e "" ]; then
    true
  else
    return 1
  fi
}

function private_entryInSource
{
  local context="$1"
  local entry="$2"
  
  if sources="$(private_getSourcesForThing "$entry" 2>/dev/null)"; then
    if [ "$(echo "$sources" | wc -l)" -gt 1 ]; then
      echo "$sources"
    fi
  else
    return 1
  fi
}

function private_isAvailable
{
  local thing="$1"
  local origin="$(readlink "$thing")"
  
  if [ -e "$origin" ]; then
    echo "Yes"
    return 0
  else
    echo "No"
    return 1
  fi
}

function list # List the items in the current workspace (current directory), and their state.
{
  if [ ! -e '.duse/context' ]; then
    echo "This does not appear to be a workspace." >&2
    return 1
  fi
  
  context="$(cat '.duse/context')"
  if stdoutIsTerminal; then
    separator='^'
  else
    separator=','
  fi
  headings="Entry${separator}Accessible${separator}Type${separator}Location"
  
  {
    # Compile together the output.
    echo "$headings"
    while read entry; do
      entryType="$(private_getEntryType "$context" "$entry")"
      
      if [ "${entryType::7}" != 'Invalid' ]; then
        entryAccessible="$(private_isAvailable "$entry")"
        entryLocation="$(private_whichSource "$context" "$(dirname "$(readlink "$entry")")")"
      else
        entryAccessible='Yes?'
        entryLocation='Not managed by duse.'
      fi
      echo "$entry$separator$entryAccessible$separator$entryType$separator$entryLocation"
    done < <(ls -1)
  } | column -t -s '^'
}

function private_listAllPossibleCachableThings
{
  if [ ! -e '.duse/context' ]; then
    echo "This does not appear to be a workspace." >&2
    return 1
  fi
  
  contextName="$(cat '.duse/context')"
  sourcesPath="$contextHome/$contextName/sources"

  
  while read source; do
    ls -1 "$(cat $sourcesPath/$source)"
  done < <(private_getSources "$contextName")
}

function listAvailable # List out the things that you can cache in the current workspace (current directory).
{
  private_listAllPossibleCachableThings | sort -u
}

function private_getSourcesForThing
{
  local thing="$1"
  
  if [ ! -e '.duse/context' ]; then
    echo "This does not appear to be a workspace." >&2
    return 1
  fi
  
  contextName="$(cat '.duse/context')"
  sourcesPath="$contextHome/$contextName/sources"

  
  while read source; do
    thingPath="$(cat $sourcesPath/$source)/$thing"
    if [ -e "$thingPath" ]; then
      echo "$thingPath"
    fi
  done < <(private_getSources "$contextName")
}

function private_getSourceForThing
{
  local thing="$1"
  
  if ! sources="$(private_getSourcesForThing "$thing")"; then
    return 1
  fi
  
  numberOfSources="$(echo "$sources" | wc -l)"
  
  if [ "$numberOfSources" -eq 0 ]; then
    echo "There don't appear to be any sources for this item. Typo?" >&2
    return 1
  elif [ "$numberOfSources" -gt 1 ]; then
    echo "There appear to be multiple sources for this item:" >&2
    echo "$sources" | sed 's/^/  /g' >&2
    echo -e "\nWill assume the first. But you should definitely fix this. You don't have a single source of truth." >&2
    echo "$sources" | head -n 1
    return "$warnExitCode"
  else
    echo "$sources"
  fi
}

function private_doUseViaParameter
{
  thing="$1"
  
  # TODO Make sure the item exists.
  if ! source="$(private_getSourceForThing "$thing")"; then
    return 1
  fi
  
  ln -s "$source" "$thing"
}

function use # Use an item (or piped items from --listAvailable), found in --listAvailable, in the current workspace. --use [itemToUse]
{
  if stdinIsTerminal; then
    if [ "$1" != '' ]; then
      private_doUseViaParameter "$1"
    else
      echo "Either specify an item, or pipe them from --listAvailable" >&2
    fi
  else
    while read entry;do
      private_doUseViaParameter "$entry"
    done
  fi
}

function private_doCacheViaParameter
{
  local thing="$1"
  
  if [ ! -e '.duse/context' ]; then
    echo "This does not appear to be a workspace." >&2
    return 1
  fi
  
  local contextName="$(cat '.duse/context')"
  local workspaceName="$(private_sourceName "$(pwd)")"
  local contextPath="$contextHome/$contextName"
  local cacheDir="$(cat "$contextPath/cache/location")"
  local source="$(private_getSourceForThing "$thing")"
  local thingDir="$cacheDir/$contextName/$thing"
  
  echo "$(pwd)/$thing"
  echo "Setup..." | indent
  mkdir -p "$thingDir/.duse/usage"
  echo "$source" > "$thingDir/.duse/source"
  touch "$thingDir/.duse/usage/$workspaceName"
  
  private_syncDir "$thingDir" | indent
  
  echo "Set symlink... $thingDir" | indent
  rm "$thing"
  ln -s "$thingDir" "$thing"
}

function private_syncDir
{
  local cacheDir="$1"
  local source="$(cat "$cacheDir/.duse/source")"
  
  echo "Sync $cacheDir..."
  rsync -ruv "$source/"* "$cacheDir" | indent
}

function cache # Switch an item( or piped items from --listAvailable) to using cache. --cache itemToCache
{
  if stdinIsTerminal; then
    if [ "$1" != '' ]; then
      private_doCacheViaParameter "$1"
    else
      listAvailable | cache
    fi
  else
    while read entry;do
      private_doCacheViaParameter "$entry"
    done
  fi
}

function private_cacheUsageForThing
{
  local contextName="$1"
  local thing="$2"
  local contextPath="$contextHome/$contextName"
  local cacheDir="$(cat "$contextPath/cache/location")"
  local thingDir="$cacheDir/$contextName/$thing"
  
  ls -1 "$thingDir/.duse/usage" 2>/dev/null | wc -l
}

function private_cleanCache
{
  local contextName="$1"
  local thing="$2"
  local cacheUsage="$(private_cacheUsageForThing "$contextName" "$thing")"
  local contextPath="$contextHome/$contextName"
  local cacheDir="$(cat "$contextPath/cache/location")"
  local thingDir="$cacheDir/$contextName/$thing"
  
  if [ ! -e "$thingDir" ]; then
    echo "private_cleanCache: cache for $thing does not exist. Will not clean." >&2
  fi
  
  if [ "$cacheUsage" -eq 0 ]; then
    rm -Rf "$thingDir"
  else
    echo "private_cleanCache: cache for $thing is not unused. Will not clean." >&2
    return 1
  fi
}

function private_doUncacheViaParameter
{
  local thing="$1"
  local contextName="$(cat '.duse/context')"
  local workspaceName="$(private_sourceName "$(pwd)")"
  local contextPath="$contextHome/$contextName"
  local cacheDir="$(cat "$contextPath/cache/location")"
  local thingDir="$cacheDir/$contextName/$thing"
  local originalSource="$(cat "$thingDir/.duse/source" 2>/dev/null)"
  local derivedSource="$(private_getSourceForThing "$thing")"
  
  echo "$(pwd)/$thing"
  
  if [ "$originalSource" != "$derivedSource" ]; then
    echo "WARN: The source appears to have changed. Updating:
    Was: $originalSource
    Now: $derivedSource" | indent >&2
  fi
  
  echo "Set symlink... $derivedSource" | indent
  rm "$thing"
  ln -s "$derivedSource" "$thing"
  
  echo "Unregister from cache... $thingDir" | indent
  rm -f "$thingDir/.duse/usage/$workspaceName"

  local cacheUsage="$(private_cacheUsageForThing "$contextName" "$thing")"
  if [ "$cacheUsage" -eq 0 ]; then
    echo "Clean cache... $thingDir" | indent
    private_cleanCache "$contextName" "$thing"
  else
    echo "No need to clean cache for $thingDir."
  fi
}

function uncache # Switch an item( or piped items from --listAvailable) back to using cache. --uncache itemToUncache
{
  if stdinIsTerminal; then
    if [ "$1" != '' ]; then
      private_doUncacheViaParameter "$1"
    else
      listAvailable | uncache
    fi
  else
    while read entry;do
      private_doUncacheViaParameter "$entry"
    done
  fi
}


# TODO uncache and update README
# TODO sync
# TODO Project wide versions of stuff.

################################################################################

function indent
{
  indentString='  '
  
  sed "s/^/$indentString/g"
}

function isTerminal
{
  channel="$1"
  
  [ -t "$channel" ]
  return "$?"
}

function stdinIsTerminal
{
  isTerminal 0
  return "$?"
}

function stdoutIsTerminal
{
  isTerminal 1
  return "$?"
}

function stderrIsTerminal
{
  isTerminal 2
  return "$?"
}


function help # Show this help.
{
  echo "Valid commands are"
  echo
  grep "^function" "$0" | grep -v '\(private_\)' | sed 's/^function *//g; s/ # /\^/g; s/^/--/g' | column -t -s '^'
}

##### Stuff for handling parameters.
function private_showCommands
{
  grep "^function" "$0" | awk '{ print $2 }' | grep -v '\(private_\)'
}

function private_isValidCommand
{
  private_showCommands | grep -q "^$1$"
  return "$?"
}

function private_getCommandFromArg
{
  if [ "${1::2}" == '--' ]; then
    command="${1:2}"
    if private_isValidCommand "$command"; then
      echo "$command"
    else
      return 1
    fi
  else
    return 1
  fi
}

if [ "$1" == '' ]; then
  help
else
  if command="$(private_getCommandFromArg "$1")"; then
    shift
    "$command" "$@"
    exit "$?"
  else
    echo "$0: Command not found." >&2
    exit 1
  fi
fi
